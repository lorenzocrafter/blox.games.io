<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Overdrive</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root {
            --c-cyan: #00f3ff;
            --c-pink: #ff00aa;
            --c-bg: #020205;
        }

        body { margin: 0; overflow: hidden; background: var(--c-bg); font-family: 'Orbitron', sans-serif; color: white; user-select: none; }
        
        #canvas-container { position: absolute; inset: 0; z-index: 1; }
        
        /* UI INTERFACE */
        #ui-layer {
            position: absolute; inset: 0; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* HUD */
        .hud {
            position: absolute; top: 0; left: 0; width: 100%; padding: 30px;
            display: flex; justify-content: space-between; pointer-events: none;
            box-sizing: border-box;
        }
        
        .hud-stats {
            text-align: left; text-shadow: 0 0 10px var(--c-cyan);
        }
        .hud-credits {
            text-align: right; text-shadow: 0 0 10px var(--c-pink);
        }
        .big-text { font-size: 2rem; font-weight: 900; line-height: 1; }
        .label { font-family: 'Rajdhani'; font-size: 1rem; opacity: 0.7; letter-spacing: 2px; }

        /* MENUS */
        .screen {
            background: rgba(2, 2, 5, 0.85); backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 100px rgba(0, 243, 255, 0.15);
            padding: 50px; width: 90%; max-width: 600px;
            border-radius: 2px; text-align: center;
            pointer-events: auto;
            display: none; flex-direction: column; gap: 25px;
            transform: scale(0.95); opacity: 0; transition: all 0.4s ease;
        }
        .screen.active { display: flex; transform: scale(1); opacity: 1; }

        h1 {
            font-size: 3.5rem; margin: 0; letter-spacing: 6px;
            background: linear-gradient(to bottom, #fff, var(--c-cyan)); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px var(--c-cyan));
        }

        /* BOTONES FUTURISTAS */
        button {
            background: rgba(0, 243, 255, 0.05); 
            border: 1px solid var(--c-cyan); 
            color: var(--c-cyan);
            padding: 15px 40px; font-family: 'Orbitron'; font-size: 1.1rem; 
            cursor: pointer; transition: 0.3s; text-transform: uppercase; letter-spacing: 3px;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
        }
        button:hover { 
            background: var(--c-cyan); color: black; 
            box-shadow: 0 0 30px var(--c-cyan);
        }
        
        button.secondary { border-color: var(--c-pink); color: var(--c-pink); background: rgba(255, 0, 170, 0.05); }
        button.secondary:hover { background: var(--c-pink); color: white; box-shadow: 0 0 30px var(--c-pink); }

        /* SHOP */
        .shop-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin: 10px 0; }
        .shop-item {
            background: rgba(255,255,255,0.03); border: 1px solid #444; padding: 15px; cursor: pointer; transition: 0.2s;
        }
        .shop-item:hover { border-color: white; background: rgba(255,255,255,0.1); transform: translateY(-2px); }
        .shop-item.active { border-color: var(--c-cyan); box-shadow: inset 0 0 20px rgba(0,243,255,0.2); }
        .shop-item.locked { opacity: 0.4; filter: grayscale(1); pointer-events: none; }
        .color-preview { width: 100%; height: 40px; margin-bottom: 10px; box-shadow: 0 0 15px currentColor; }

        /* MOBILE CONTROLS */
        #mobile-overlay { display: none; position: absolute; bottom: 0; width: 100%; height: 40%; z-index: 99; }
        .touch-zone { width: 50%; height: 100%; float: left; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud" id="hud" style="display: none;">
            <div class="hud-stats">
                <div class="label">DISTANCE</div>
                <div class="big-text" id="score-el">0</div>
            </div>
            <div class="hud-credits">
                <div class="label">CREDITS</div>
                <div class="big-text" id="credits-el">0</div>
            </div>
        </div>

        <div id="menu-screen" class="screen active">
            <h1>NEON<br>OVERDRIVE</h1>
            <p style="color:#aaa; font-family:'Rajdhani'; margin:0;">HIGH SCORE: <span id="menu-best" style="color:white">0</span></p>
            <div style="display:flex; gap:15px; justify-content:center; margin-top:20px;">
                <button onclick="Game.start()">IGNITION</button>
            </div>
            <button class="secondary" onclick="UI.openShop()">GARAGE</button>
        </div>

        <div id="shop-screen" class="screen">
            <h2 style="color:var(--c-cyan); margin:0;">GARAGE</h2>
            <div class="label">BALANCE: $<span id="shop-credits">0</span></div>
            <div class="shop-grid" id="shop-list"></div>
            <button class="secondary" onclick="UI.openMenu()">BACK</button>
        </div>

        <div id="gameover-screen" class="screen">
            <h1 style="font-size:3rem; color:var(--c-pink); text-shadow:0 0 20px red;">CRITICAL<br>FAILURE</h1>
            <div>
                <div class="label">DISTANCE RUN</div>
                <div class="big-text" id="go-score">0</div>
            </div>
            <div>
                <div class="label">CREDITS EARNED</div>
                <div class="big-text" style="color:var(--c-cyan)">+<span id="go-credits">0</span></div>
            </div>
            <div style="display:flex; gap:15px; justify-content:center; margin-top:20px;">
                <button onclick="Game.start()">RETRY</button>
                <button class="secondary" onclick="UI.openMenu()">MENU</button>
            </div>
        </div>
    </div>

    <div id="mobile-overlay">
        <div class="touch-zone" id="t-left"></div>
        <div class="touch-zone" id="t-right"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        // IMPORTAMOS EFECTOS DE POST-PROCESADO (BLOOM)
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN ---
        const CONFIG = {
            tunnelRadius: 40,
            speedBase: 1.5,
            camDistance: 35,  // ¡AQUÍ ESTÁ LA CLAVE! Más lejos
            camHeight: 12,    // Más arriba para ver la estela
            colors: [0x00f3ff, 0xff00aa, 0x00ff66, 0xffea00, 0xffffff]
        };

        // --- DATA ---
        const DB = {
            state: {
                credits: 0, highScore: 0, 
                unlocked: ['ship_0'], equipped: 'ship_0'
            },
            ships: [
                { id: 'ship_0', name: 'Pulse', color: 0x00f3ff, price: 0 },
                { id: 'ship_1', name: 'Viper', color: 0xff00aa, price: 300 },
                { id: 'ship_2', name: 'Venom', color: 0x00ff66, price: 600 },
                { id: 'ship_3', name: 'Solar', color: 0xffea00, price: 1200 },
                { id: 'ship_4', name: 'Ghost', color: 0xffffff, price: 2500 }
            ],
            load() {
                const s = localStorage.getItem('neon_od_save');
                if(s) this.state = JSON.parse(s);
            },
            save() { localStorage.setItem('neon_od_save', JSON.stringify(this.state)); },
            getColor() { return this.ships.find(s => s.id === this.state.equipped).color; }
        };

        // --- VISUAL FX MANAGER ---
        class VFX {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                // Geometría reutilizable para partículas
                this.geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                this.mat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, transparent: true, opacity: 1 
                });
            }

            emitTrail(pos, color) {
                const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                mesh.position.copy(pos);
                // Aleatoriedad para efecto fuego
                mesh.position.x += (Math.random()-0.5)*1;
                mesh.position.y += (Math.random()-0.5)*1;
                mesh.material.color.setHex(color);
                mesh.userData = { life: 1.0, speed: (Math.random()*0.5)+0.5 };
                
                this.scene.add(mesh);
                this.particles.push(mesh);
            }

            update() {
                for(let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.userData.life -= 0.03; // Desvanecimiento
                    p.position.z += 2.0; // Se alejan rápido (efecto velocidad)
                    p.scale.setScalar(p.userData.life * 1.5);
                    p.rotation.z += 0.1;
                    p.material.opacity = p.userData.life;

                    if(p.userData.life <= 0) {
                        this.scene.remove(p);
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            reset() {
                this.particles.forEach(p => this.scene.remove(p));
                this.particles = [];
            }
        }

        // --- UI ---
        const UI = {
            screens: { menu:null, shop:null, gameover:null, hud:null },
            els: {},
            init() {
                ['menu','shop','gameover'].forEach(id => 
                    this.screens[id] = document.getElementById(id+'-screen'));
                this.screens.hud = document.getElementById('hud');
                
                ['score','credits','menu-best','shop-credits','go-score','go-credits'].forEach(id =>
                    this.els[id] = document.getElementById(id.includes('-') ? id : id+'-el'));
                
                this.els.shopList = document.getElementById('shop-list');
                DB.load();
                this.update();
            },
            show(id) {
                Object.values(this.screens).forEach(s => s.classList.remove('active'));
                if(id === 'hud') this.screens.hud.style.display = 'flex';
                else {
                    this.screens.hud.style.display = 'none';
                    this.screens[id].classList.add('active');
                }
            },
            update() {
                this.els['menu-best'].innerText = Math.floor(DB.state.highScore);
                this.els['shop-credits'].innerText = DB.state.credits;
            },
            openMenu() { this.update(); this.show('menu'); },
            openShop() {
                this.els.shopList.innerHTML = '';
                DB.ships.forEach(ship => {
                    const unlocked = DB.state.unlocked.includes(ship.id);
                    const equipped = DB.state.equipped === ship.id;
                    const el = document.createElement('div');
                    el.className = `shop-item ${equipped?'active':''} ${!unlocked?'locked':''}`;
                    el.innerHTML = `
                        <div class="color-preview" style="background:#${ship.color.toString(16)}; box-shadow:0 0 10px #${ship.color.toString(16)}"></div>
                        <div style="font-size:0.8rem; font-weight:bold">${ship.name}</div>
                        <div style="color:${unlocked?'#fff':'var(--c-pink)'}">${unlocked?(equipped?'EQUIPPED':'OWNED'):'$'+ship.price}</div>
                    `;
                    
                    if(!unlocked) {
                        // Lógica de compra desbloqueada al hacer click si tienes dinero (simplificado para UI limpia)
                        el.classList.remove('locked'); // Visual hack para permitir click
                        el.style.opacity = "0.6";
                    }
                    
                    el.onclick = () => {
                        if(unlocked) {
                            DB.state.equipped = ship.id;
                            DB.save();
                            this.openShop();
                        } else if(DB.state.credits >= ship.price) {
                            DB.state.credits -= ship.price;
                            DB.state.unlocked.push(ship.id);
                            DB.state.equipped = ship.id;
                            DB.save();
                            this.openShop();
                        } else {
                            el.style.borderColor = 'red';
                            setTimeout(()=>el.style.borderColor='#444', 200);
                        }
                    };
                    this.els.shopList.appendChild(el);
                });
                this.show('shop');
            }
        };

        // --- ENGINE ---
        class Engine {
            constructor() {
                this.initThree();
                this.initWorld();
                this.initPlayer();
                this.vfx = new VFX(this.scene);
                
                this.state = { playing: false, speed: 0, score: 0, angle: -Math.PI/2, velocity: 0 };
                this.keys = { left: false, right: false };
                
                this.bindEvents();
                UI.init();
                UI.openMenu();
                
                this.loop();
            }

            initThree() {
                this.scene = new THREE.Scene();
                // Niebla densa para ocultar el final del tunel
                this.scene.fog = new THREE.FogExp2(0x020205, 0.015);
                
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: false }); // Bloom needs false usually for perf
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance limit
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // LUCES
                const ambient = new THREE.AmbientLight(0xffffff, 0.1); // Oscuro
                this.scene.add(ambient);
                
                // Luz direccional que simula "el final del tunel"
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(0, 0, -100);
                this.scene.add(dirLight);

                // POST-PROCESADO (BLOOM)
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                const bloom = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85 // Strength, Radius, Threshold
                );
                this.composer.addPass(bloom);
            }

            initWorld() {
                this.tunnel = new THREE.Group();
                this.scene.add(this.tunnel);
                this.segments = [];
                this.obstacles = [];
                this.coins = [];

                // Generar estrellas de fondo
                const starsGeo = new THREE.BufferGeometry();
                const starCount = 1000;
                const posArray = new Float32Array(starCount * 3);
                for(let i=0; i<starCount*3; i++) posArray[i] = (Math.random()-0.5)*600;
                starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starsMat = new THREE.PointsMaterial({size: 0.5, color: 0xffffff});
                this.scene.add(new THREE.Points(starsGeo, starsMat));
                
                // Generar Tunel Inicial
                for(let i=0; i<50; i++) this.spawnSegment(-i * 20);
            }

            spawnSegment(z) {
                // Hexágono con borde brillante
                const pts = [];
                const segs = 6;
                const r = CONFIG.tunnelRadius;
                for(let i=0; i<=segs; i++) {
                    const t = (i/segs)*Math.PI*2;
                    pts.push(new THREE.Vector3(Math.cos(t)*r, Math.sin(t)*r, 0));
                }
                
                const geo = new THREE.BufferGeometry().setFromPoints(pts);
                const mat = new THREE.LineBasicMaterial({ color: 0x333333 });
                
                // Variación: Anillos brillantes cada tanto
                if(Math.random() > 0.8) {
                    mat.color.setHex(0x444444);
                    mat.opacity = 0.5;
                }

                const ring = new THREE.Line(geo, mat);
                ring.position.z = z;
                this.tunnel.add(ring);
                this.segments.push(ring);

                // Spawneo
                if(z < -100 && Math.random() < 0.35) {
                    this.spawnEntity(z);
                }
            }

            spawnEntity(z) {
                const isObs = Math.random() > 0.3;
                const angle = Math.floor(Math.random()*6) * (Math.PI/3); // Alinear a paredes hexágono
                const r = CONFIG.tunnelRadius - 4;
                const x = Math.cos(angle)*r;
                const y = Math.sin(angle)*r;

                if(isObs) {
                    // Obstáculo: Cubo Neón Rojo
                    const geo = new THREE.BoxGeometry(6, 2, 6);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: 0x000000, emissive: 0xff0000, emissiveIntensity: 2 
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x, y, z);
                    mesh.rotation.z = angle + Math.PI/2;
                    this.scene.add(mesh);
                    this.obstacles.push({mesh, angle});
                } else {
                    // Moneda: Diamante Amarillo
                    const geo = new THREE.OctahedronGeometry(1.5);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffea00 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x*0.9, y*0.9, z); // Flotando un poco
                    this.scene.add(mesh);
                    this.coins.push({mesh, angle});
                }
            }

            initPlayer() {
                this.player = new THREE.Group();
                
                // DISEÑO DE NAVE (Tipo F-Zero)
                // Cuerpo central
                const body = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5, 7, 4),
                    new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 })
                );
                body.rotation.x = Math.PI/2;
                body.rotation.y = Math.PI/4;
                this.player.add(body);

                // Cabina brillante
                const cockpit = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.5, 2),
                    new THREE.MeshBasicMaterial({ color: 0x000000 }) // El color viene del estado
                );
                cockpit.position.set(0, 0.8, 0.5);
                this.cockpitMat = cockpit.material;
                this.player.add(cockpit);

                // Alas
                const wings = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.1, 3),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                wings.position.set(0, 0, 1.5);
                this.player.add(wings);

                // Motores (Emisores de partículas)
                const engGeo = new THREE.CylinderGeometry(0.3, 0.1, 1, 8);
                engGeo.rotateX(Math.PI/2);
                const engMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                
                this.leftEng = new THREE.Mesh(engGeo, engMat);
                this.leftEng.position.set(-1.5, 0, 3.5);
                this.player.add(this.leftEng);
                
                this.rightEng = new THREE.Mesh(engGeo, engMat);
                this.rightEng.position.set(1.5, 0, 3.5);
                this.player.add(this.rightEng);

                this.scene.add(this.player);
                this.updateShipColor();
            }

            updateShipColor() {
                const c = DB.getColor();
                this.cockpitMat.color.setHex(c);
                // También cambiamos la luz del túnel para ambientar
                this.scene.fog.color.setHex(0x020205);
            }

            bindEvents() {
                const onKey = (k, v) => {
                    if(k==='ArrowLeft') this.keys.left = v;
                    if(k==='ArrowRight') this.keys.right = v;
                };
                window.addEventListener('keydown', e => onKey(e.key, true));
                window.addEventListener('keyup', e => onKey(e.key, false));

                // Mobile
                const tl = document.getElementById('t-left');
                const tr = document.getElementById('t-right');
                if('ontouchstart' in window) {
                    document.getElementById('mobile-overlay').style.display = 'block';
                    tl.addEventListener('touchstart', e=>{e.preventDefault(); this.keys.left=true;});
                    tl.addEventListener('touchend', e=>{e.preventDefault(); this.keys.left=false;});
                    tr.addEventListener('touchstart', e=>{e.preventDefault(); this.keys.right=true;});
                    tr.addEventListener('touchend', e=>{e.preventDefault(); this.keys.right=false;});
                }
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            // --- LOGIC ---
            start() {
                this.reset();
                this.state.playing = true;
                this.state.speed = CONFIG.speedBase;
                UI.show('hud');
            }

            reset() {
                this.state.score = 0;
                this.state.speed = 0;
                this.state.angle = -Math.PI/2;
                this.state.velocity = 0;
                
                this.obstacles.forEach(o => this.scene.remove(o.mesh));
                this.obstacles = [];
                this.coins.forEach(c => this.scene.remove(c.mesh));
                this.coins = [];
                
                this.vfx.reset();
                this.updateShipColor();
            }

            gameOver() {
                this.state.playing = false;
                if(this.state.score > DB.state.highScore) DB.state.highScore = this.state.score;
                DB.save();
                UI.triggerGameOver(this.state.score, this.state.credits - parseInt(UI.els.shopCredits.innerText || 0));
                // Hack simple para mostrar creditos ganados en sesion (credits actual - credits al inicio)
                // Mejor: UI.triggerGameOver(score, collectedSessionCredits)
            }

            update() {
                if(!this.state.playing) {
                    // Idle rotation
                    this.tunnel.rotation.z += 0.001;
                    this.renderer.render(this.scene, this.camera);
                    return;
                }

                // 1. FÍSICA DE NAVE (Drift suave)
                const acc = 0.004;
                const friction = 0.94;
                const maxVel = 0.08;

                if(this.keys.left) this.state.velocity += acc;
                if(this.keys.right) this.state.velocity -= acc;
                this.state.velocity *= friction;
                
                this.state.angle += this.state.velocity;

                // 2. POSICIONAMIENTO 3D
                const r = CONFIG.tunnelRadius - 8; // Volar dentro, no en el borde
                const x = Math.cos(this.state.angle) * r;
                const y = Math.sin(this.state.angle) * r;
                
                this.player.position.set(x, y, 0);
                
                // Rotaciones complejas para realismo
                this.player.rotation.z = this.state.angle - Math.PI/2; // Alinear al tunel
                this.player.rotation.y = this.state.velocity * 5; // Banking (inclinacion)
                this.player.rotation.x = -this.state.speed * 0.05; // Pitch por velocidad

                // 3. CÁMARA (LA CORRECCIÓN GRANDE)
                // Calculamos posición ideal de la cámara: Detrás y Arriba (relativo al centro del tunel)
                const camR = r - CONFIG.camHeight; 
                const camX = Math.cos(this.state.angle) * camR;
                const camY = Math.sin(this.state.angle) * camR;
                
                // Interpolación suave (Lerp) para que la cámara no sea rígida
                this.camera.position.x += (camX - this.camera.position.x) * 0.1;
                this.camera.position.y += (camY - this.camera.position.y) * 0.1;
                this.camera.position.z = CONFIG.camDistance;
                
                // Mirar un poco adelante de la nave
                this.camera.lookAt(x*0.5, y*0.5, -50);
                
                // Ajustar la rotación Z de la cámara para seguir el giro del mundo
                this.camera.rotation.z = (this.state.angle - Math.PI/2) * 0.3; // 0.3 factor de suavizado

                // 4. ENTORNO (Mover el mundo hacia el jugador)
                const spd = this.state.speed;
                this.state.score += spd * 0.1;
                this.state.speed += 0.0002; // Aceleración progresiva
                if(this.state.speed > CONFIG.speedMax) this.state.speed = CONFIG.speedMax;

                // Mover segmentos
                this.segments.forEach(seg => {
                    seg.position.z += spd;
                    if(seg.position.z > CONFIG.camDistance) { // Si pasa la camara
                        seg.position.z -= (this.segments.length * 20);
                        if(Math.random() < 0.4) this.spawnEntity(seg.position.z);
                    }
                });

                // Mover Obstaculos
                for(let i=this.obstacles.length-1; i>=0; i--) {
                    const o = this.obstacles[i];
                    o.mesh.position.z += spd;
                    
                    // Colision
                    if(Math.abs(o.mesh.position.z) < 3) {
                        if(this.checkHit(o.angle, 0.5)) {
                            this.gameOver();
                        }
                    }
                    if(o.mesh.position.z > CONFIG.camDistance) {
                        this.scene.remove(o.mesh);
                        this.obstacles.splice(i, 1);
                    }
                }

                // Mover Monedas
                for(let i=this.coins.length-1; i>=0; i--) {
                    const c = this.coins[i];
                    c.mesh.position.z += spd;
                    c.mesh.rotation.z += 0.1;
                    
                    if(Math.abs(c.mesh.position.z) < 3) {
                        if(this.checkHit(c.angle, 0.8)) { // Hitbox mas grande
                            DB.state.credits += 10;
                            this.scene.remove(c.mesh);
                            this.coins.splice(i, 1);
                            continue;
                        }
                    }
                    if(c.mesh.position.z > CONFIG.camDistance) {
                        this.scene.remove(c.mesh);
                        this.coins.splice(i, 1);
                    }
                }

                // VFX
                const c = DB.getColor();
                const p1 = new THREE.Vector3(); this.leftEng.getWorldPosition(p1);
                const p2 = new THREE.Vector3(); this.rightEng.getWorldPosition(p2);
                this.vfx.emitTrail(p1, c);
                this.vfx.emitTrail(p2, c);
                this.vfx.update();

                // HUD Update
                UI.els.score.innerText = Math.floor(this.state.score);
                UI.els.credits.innerText = DB.state.credits;

                // Render Bloom
                this.composer.render();
            }

            checkHit(objAngle, tolerance) {
                let diff = Math.abs(this.state.angle - objAngle);
                diff = diff % (Math.PI*2);
                if(diff > Math.PI) diff = (Math.PI*2) - diff;
                return diff < tolerance;
            }

            loop() {
                requestAnimationFrame(() => this.loop());
                this.update();
            }
        }

        window.onload = () => { window.Game = new Engine(); };

    </script>
</body>
</html>
