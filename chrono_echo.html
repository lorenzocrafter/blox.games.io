<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHRONO ECHO: REBIRTH</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --c-bg: #050508;
            --c-grid: #1a1a24;
            --c-player: #00f3ff;
            --c-enemy: #ff0055;
            --c-echo: #aa00ff;
            --c-text: #ffffff;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
            border: 2px solid #333;
        }

        canvas {
            display: block;
            cursor: crosshair;
            background: radial-gradient(circle at center, #0a0a12 0%, #000000 100%);
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-family: 'Share Tech Mono', monospace;
            text-shadow: 0 0 10px var(--c-player);
        }

        .hud-stat {
            font-size: 1.5rem;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border: 1px solid #333;
            border-left: 3px solid var(--c-player);
        }

        #timer-bar-container {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 6px;
            background: #222;
        }
        #timer-bar {
            height: 100%;
            width: 100%;
            background: var(--c-player);
            box-shadow: 0 0 15px var(--c-player);
            transform-origin: left;
            transition: transform 0.1s linear;
        }

        /* MENUS */
        .menu-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 4rem; margin: 0;
            text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, var(--c-player));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px var(--c-player));
            letter-spacing: 5px;
        }

        p { font-family: 'Share Tech Mono'; color: #888; margin-bottom: 30px; }

        button {
            background: transparent;
            color: var(--c-player);
            font-family: 'Share Tech Mono';
            font-size: 1.5rem;
            padding: 15px 40px;
            border: 1px solid var(--c-player);
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: var(--c-player);
            color: #000;
            box-shadow: 0 0 30px var(--c-player);
        }

        .hidden { display: none !important; }
        
        .control-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-family: 'Share Tech Mono';
            opacity: 0.5;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        
        <div id="timer-bar-container"><div id="timer-bar"></div></div>

        <div id="ui-layer">
            <div class="hud-top" id="hud" class="hidden">
                <div class="hud-stat">ROUND: <span id="round-val">1</span></div>
                <div class="hud-stat">SCORE: <span id="score-val">0</span></div>
            </div>
        </div>

        <div id="start-screen" class="menu-screen">
            <h1>CHRONO ECHO</h1>
            <p>THE PAST IS YOUR ENEMY</p>
            <button id="btn-start">INITIALIZE</button>
            <div class="control-hint">WASD to Move • CLICK to Shoot</div>
        </div>

        <div id="gameover-screen" class="menu-screen hidden">
            <h1 style="color:var(--c-enemy); filter: drop-shadow(0 0 20px var(--c-enemy));">PARADOX</h1>
            <p>TIMELINE COLLAPSED</p>
            <div style="font-size: 1.5rem; margin-bottom: 20px;">SCORE: <span id="final-score">0</span></div>
            <button id="btn-retry">REWIND</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            roundTime: 12, // Segundos por ronda
            playerSpeed: 4,
            bulletSpeed: 10,
            enemySpeed: 2,
            fireRate: 150, // ms entre disparos
            colors: {
                player: '#00f3ff',
                echo: '#aa00ff',
                enemy: '#ff0055',
                bulletPlayer: '#ccffff',
                bulletEcho: '#ffaa00',
                grid: '#1a1a24'
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- GAME STATE ---
        let state = {
            screen: 'start', // start, playing, gameover
            round: 1,
            score: 0,
            timeLeft: 0,
            lastTime: 0,
            shake: 0
        };

        // --- INPUTS ---
        const mouse = { x: 0, y: 0 };
        const keys = { w:false, a:false, s:false, d:false };
        let isMouseDown = false;

        // --- ENTITIES LISTS ---
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let echoes = []; // Los fantasmas
        
        // --- RECORDING SYSTEM ---
        let currentRecording = []; // Graba la ronda actual {x, y, angle, shoot}
        let pastRecordings = []; // Array de arrays con rondas anteriores

        // --- CLASSES ---

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
        }

        class Player {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.angle = 0;
                this.lastShot = 0;
                this.dead = false;
                this.recoil = 0;
            }

            update(dt) {
                if(this.dead) return;

                // Movement
                let dx = 0, dy = 0;
                if(keys.w) dy -= 1;
                if(keys.s) dy += 1;
                if(keys.a) dx -= 1;
                if(keys.d) dx += 1;

                // Normalize vector
                if(dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx*dx + dy*dy);
                    dx /= len; dy /= len;
                    this.pos.x += dx * CONFIG.playerSpeed;
                    this.pos.y += dy * CONFIG.playerSpeed;
                }

                // Clamp to screen
                this.pos.x = Math.max(20, Math.min(canvas.width-20, this.pos.x));
                this.pos.y = Math.max(20, Math.min(canvas.height-20, this.pos.y));

                // Aim
                this.angle = Math.atan2(mouse.y - this.pos.y, mouse.x - this.pos.x);

                // Recoil recovery
                if(this.recoil > 0) this.recoil -= 0.5;

                // Shoot
                if(isMouseDown && Date.now() - this.lastShot > CONFIG.fireRate) {
                    this.shoot();
                }

                // Record Frame
                if(state.screen === 'playing') {
                    currentRecording.push({
                        x: this.pos.x,
                        y: this.pos.y,
                        a: this.angle,
                        s: isMouseDown && (Date.now() - this.lastShot < 20) // Mark frame as shot
                    });
                }
            }

            shoot() {
                this.lastShot = Date.now();
                this.recoil = 5;
                state.shake = 2;
                
                // Bullet spawn point (tip of gun)
                const gunLen = 25;
                const bx = this.pos.x + Math.cos(this.angle) * gunLen;
                const by = this.pos.y + Math.sin(this.angle) * gunLen;
                
                bullets.push(new Bullet(bx, by, this.angle, 'player'));
                spawnParticles(bx, by, CONFIG.colors.player, 3);
            }

            draw(ctx) {
                if(this.dead) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);

                // --- DIBUJO DEL SOLDADO PROCEDURAL ---
                
                // Sombras
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.colors.player;

                // Arma (Gun)
                ctx.fillStyle = '#333';
                ctx.fillRect(5 - this.recoil, -4, 20, 8); // Cuerpo arma
                ctx.fillStyle = '#555';
                ctx.fillRect(5 - this.recoil, -4, 10, 8); // Grip

                // Brazos (Arms)
                ctx.fillStyle = '#008899'; // Color traje
                ctx.beginPath();
                ctx.arc(0, -8, 6, 0, Math.PI*2); // Hombro izq
                ctx.arc(0, 8, 6, 0, Math.PI*2); // Hombro der
                ctx.fill();

                // Manos
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(15 - this.recoil, 2, 4, 0, Math.PI*2); // Mano derecha en gatillo
                ctx.arc(10 - this.recoil, -2, 4, 0, Math.PI*2); // Mano izq en cañon
                ctx.fill();

                // Cabeza / Casco
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(0, 0, 9, 0, Math.PI*2);
                ctx.fill();
                
                // Visor brillante
                ctx.fillStyle = CONFIG.colors.player;
                ctx.beginPath();
                ctx.rect(2, -3, 6, 6); // Visor
                ctx.fill();

                ctx.restore();
            }
        }

        class Echo {
            constructor(tape, id) {
                this.tape = tape;
                this.frame = 0;
                this.color = `hsl(${id * 40}, 100%, 60%)`; // Color único por eco
                this.dead = false;
            }

            update() {
                if(this.dead) return;
                if(this.frame >= this.tape.length) {
                    // Loop o quedarse quieto (quedarse quieto es mejor visualmente)
                    return; 
                }

                const data = this.tape[this.frame];
                
                // Replay shoot
                if(data.s) {
                    const gunLen = 25;
                    const bx = data.x + Math.cos(data.a) * gunLen;
                    const by = data.y + Math.sin(data.a) * gunLen;
                    bullets.push(new Bullet(bx, by, data.a, 'echo', this.color));
                }

                this.frame++;
            }

            draw(ctx) {
                if(this.dead || this.frame >= this.tape.length) return;
                const data = this.tape[this.frame];

                ctx.save();
                ctx.translate(data.x, data.y);
                ctx.rotate(data.a);
                ctx.globalAlpha = 0.6; // Fantasmal

                // Dibujo simplificado para el Eco
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                
                ctx.fillStyle = this.color;
                ctx.fillRect(5, -3, 20, 6); // Arma brillante
                
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(0, 0, 9, 0, Math.PI*2); // Casco
                ctx.fill();
                
                // Visor
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.rect(2, -3, 6, 6);
                ctx.fill();

                ctx.restore();
            }
        }

        class Enemy {
            constructor() {
                // Spawn outside random edge
                if(Math.random() < 0.5) {
                    this.pos = new Vector(Math.random() < 0.5 ? -20 : canvas.width+20, Math.random() * canvas.height);
                } else {
                    this.pos = new Vector(Math.random() * canvas.width, Math.random() < 0.5 ? -20 : canvas.height+20);
                }
                this.dead = false;
            }

            update() {
                // Chase player
                const angle = Math.atan2(player.pos.y - this.pos.y, player.pos.x - this.pos.x);
                this.pos.x += Math.cos(angle) * CONFIG.enemySpeed;
                this.pos.y += Math.sin(angle) * CONFIG.enemySpeed;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                // Enemy shape (Diamond)
                ctx.rotate(Math.atan2(player.pos.y - this.pos.y, player.pos.x - this.pos.x));
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.enemy;
                ctx.fillStyle = CONFIG.colors.enemy;
                
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(-5, 8);
                ctx.lineTo(-5, -8);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, owner, colorOverride) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(Math.cos(angle)*CONFIG.bulletSpeed, Math.sin(angle)*CONFIG.bulletSpeed);
                this.owner = owner; // 'player' or 'echo'
                this.color = colorOverride || CONFIG.colors.player;
                this.dead = false;
            }

            update() {
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;

                // Offscreen check
                if(this.pos.x < 0 || this.pos.x > canvas.width || this.pos.y < 0 || this.pos.y > canvas.height) {
                    this.dead = true;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.pos = new Vector(x, y);
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 3;
                this.vel = new Vector(Math.cos(a)*s, Math.sin(a)*s);
                this.life = 1.0;
                this.color = color;
            }
            update() {
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.pos.x, this.pos.y, 3, 3);
                ctx.globalAlpha = 1;
            }
        }

        function spawnParticles(x, y, color, count=10) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        // --- CORE FUNCTIONS ---

        function init() {
            // Input listeners
            window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener('mousemove', e => {
                const r = canvas.getBoundingClientRect();
                mouse.x = e.clientX - r.left;
                mouse.y = e.clientY - r.top;
            });
            canvas.addEventListener('mousedown', () => isMouseDown = true);
            canvas.addEventListener('mouseup', () => isMouseDown = false);

            // UI Buttons
            document.getElementById('btn-start').onclick = startGame;
            document.getElementById('btn-retry').onclick = startGame;

            requestAnimationFrame(loop);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            player = new Player(canvas.width/2, canvas.height/2);
            bullets = [];
            enemies = [];
            particles = [];
            echoes = [];
            pastRecordings = [];
            currentRecording = [];
            
            state.score = 0;
            state.round = 1;
            startRound();
            
            state.screen = 'playing';
            state.lastTime = Date.now();
        }

        function startRound() {
            state.timeLeft = CONFIG.roundTime;
            currentRecording = [];
            bullets = []; // Clear bullets for fairness
            
            // Create Echoes from past recordings
            echoes = pastRecordings.map((tape, i) => new Echo(tape, i));
            
            // Respawn player center
            player.pos.x = canvas.width/2;
            player.pos.y = canvas.height/2;
            
            document.getElementById('round-val').innerText = state.round;
        }

        function endRound() {
            // Save tape
            if(currentRecording.length > 0) pastRecordings.push(currentRecording);
            state.round++;
            startRound();
        }

        function gameOver() {
            state.screen = 'gameover';
            document.getElementById('gameover-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('hud').classList.add('hidden');
        }

        function loop() {
            requestAnimationFrame(loop);
            
            // Clear & Background Grid
            ctx.fillStyle = CONFIG.colors.grid;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Grid Lines
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            // Screenshake offset
            let sx = 0, sy = 0;
            if(state.shake > 0) {
                sx = (Math.random()-0.5)*state.shake;
                sy = (Math.random()-0.5)*state.shake;
                state.shake *= 0.9;
                if(state.shake < 0.1) state.shake = 0;
            }
            ctx.save();
            ctx.translate(sx, sy);

            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            if(state.screen === 'playing') {
                const dt = 0.016; // Fixed delta approx

                // Timer
                state.timeLeft -= dt;
                const pct = Math.max(0, state.timeLeft / CONFIG.roundTime);
                document.getElementById('timer-bar').style.transform = `scaleX(${pct})`;
                
                if(state.timeLeft <= 0) endRound();

                // Spawn Enemies
                if(Math.random() < 0.02 + (state.round * 0.005)) enemies.push(new Enemy());

                // Updates
                player.update(dt);
                echoes.forEach(e => e.update());
                
                bullets.forEach((b, i) => {
                    b.update();
                    if(b.dead) bullets.splice(i, 1);
                });

                enemies.forEach((e, i) => {
                    e.update();
                    // Collision Enemy vs Player
                    const dist = Math.hypot(e.pos.x - player.pos.x, e.pos.y - player.pos.y);
                    if(dist < 20) gameOver();
                });

                particles.forEach((p, i) => {
                    p.update();
                    if(p.life <= 0) particles.splice(i, 1);
                });

                // Collisions: Bullets vs Enemies
                bullets.forEach(b => {
                    if(b.dead) return;
                    enemies.forEach((e, i) => {
                        if(e.dead) return;
                        if(Math.hypot(b.pos.x - e.pos.x, b.pos.y - e.pos.y) < 15) {
                            // Kill Enemy
                            e.dead = true;
                            b.dead = true;
                            state.score += 100;
                            document.getElementById('score-val').innerText = state.score;
                            spawnParticles(e.pos.x, e.pos.y, CONFIG.colors.enemy, 10);
                            state.shake = 5;
                        }
                    });
                    // Collisions: Bullets vs Player (Friendly Fire from Echoes!)
                    // Only Echo bullets kill player
                    if(b.owner === 'echo') {
                        if(Math.hypot(b.pos.x - player.pos.x, b.pos.y - player.pos.y) < 10) {
                            gameOver();
                            spawnParticles(player.pos.x, player.pos.y, CONFIG.colors.player, 20);
                        }
                    }
                });
                
                // Cleanup dead enemies
                enemies = enemies.filter(e => !e.dead);
            }

            // Draws
            particles.forEach(p => p.draw(ctx));
            bullets.forEach(b => b.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            echoes.forEach(e => e.draw(ctx));
            if(state.screen !== 'gameover') player.draw(ctx);

            ctx.restore();
        }

        init();

    </script>
</body>
</html>
